#!/usr/bin/env python2

# sample_backup backup -B /BackupPrefix [-P <parentId>] /eos/pathName
# sample_backup restore -B /BackupPrefix -F /inputCatalog1[,/inputCatalog2[,...]] /outputDirectory


# for backup the data are stored in /BackupPrefix.cloneId and /BackupPrefix.cloneId.catalog
# the /eos pathnames are as seen by the MGM, not necessarily fuse-mounted paths in the local file system

# environment:
#   EOS_MGM_URL=root://eos-mgm-test.eoscluster.cern.ch must point to the MGM serving /eos/pathName

import getopt, os, sys, tempfile
import pdb

backupDirPrefix = "/tmp/backupDir"
eos_instance = os.popen("eos version").readlines()[0].split('=')[1].rstrip()
eos_mgm_url = os.environ['EOS_MGM_URL']

def do_clone(args):
    global backupDirPrefix
    parentId = 10
    opts, args = getopt.getopt(args, "B:P:")
    for opt in opts:
	if opt[0] == '-B': backupDirPrefix = opt[1]
        elif opt[0] == '-P':
            try:
                parentId = int(opt[1])
            except ValueError:
                print "invalid parent Id"
                sys.exit(22)

    catalogFile = tempfile.mkstemp(prefix=backupDirPrefix)
    
    try:
        f = os.fdopen(catalogFile[0], "w")
    except IOError as e:
        print "cannot open %s: %s" % (catalogFile[1], e.message)
        sys.exit(5)

    cmd = "eos find -f -x sys.clone=+%d %s" % (parentId, args[0])
    findOut = os.popen(cmd).readlines()

    (rootPath, ttt) = findOut[0].split(' ')	# the rootPath includes the trailing '/'
    cloneInfo = ttt.split(':')
    cloneId = cloneInfo[1]


    for l in findOut: f.write(l)
    f.close()
    newCatFile = "%s.%s.catalog" % (backupDirPrefix, cloneId)
    os.rename(catalogFile[1], newCatFile)
    print "cloneId %s catalog %s" % (cloneId, newCatFile)

    return cloneId

    
def do_backup(args):
    global backupDirPrefix
    opts, args = getopt.getopt(args, "F:B:P:")
    catalogFile = None
    for opt in opts:
        if   opt[0] == '-B': backupDirPrefix = opt[1]
        elif opt[0] == '-F': catalogFile = opt[1]
        elif opt[0] == '-P':
            try:
                parentId = int(opt[1])
            except ValueError:
                print "invalid parent Id"
                sys.exit(22)

    if catalogFile is None:
        cloneId = do_clone(args)
        catalogFile = "%s.%s.catalog" % (backupDirPrefix, cloneId)
    
    try:
        f = open(catalogFile, "r")
    except IOError as e:
        print "cannot open %s: %s" % (catalogFile, e.message)
        sys.exit(5)

    findOut = f.readlines()

    (rootPath, ttt) = findOut[0].split(' ')	# the rootPath includes the trailing '/'
    cloneInfo = ttt.split(':')
    cloneId = cloneInfo[1]

    backupDir = "%s.%s/" % (backupDirPrefix, cloneId)
    cloneDir = "/eos/%s/proc/clone/" % (eos_instance)

    print "cloneId %s backup media %s" % (cloneId, backupDir)

    for l in findOut:
        path, cloneInfo = l.split()
        rpath = path[len(rootPath):]	# skip the "root" part
        if path.endswith('/'): 		    # this is a directory
            os.makedirs(backupDir + rpath)
        else:				            # this is a file
            stime, clonePath = cloneInfo.split(':')[0:2]
            fCloneId = clonePath.split('/')[0]
            if fCloneId != cloneId: continue		# file has not been modified in incremental dump
            cpath = cloneDir + clonePath

            # try clone first
            cmd1 = "xrdcp %s/%s %s/%s 2>&1" % (eos_mgm_url, cpath, backupDir, rpath)
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc > 256: rc = rc >> 8		# recover xrdcp return code

            if rc > 0:
                # clone live file
                cmd2 = "xrdcp %s/%s %s/%s 2>&1" % (eos_mgm_url, path, backupDir, rpath)
                p2 = os.popen(cmd2)
                x2 = p2.readlines()
                rc = p2.close()
                if rc > 256: rc = rc >> 8	# recover xrdcp return code

            # retry clone if created in the meantime
            p1 = os.popen(cmd1)
            x1 = p1.readlines()
            rc = p1.close()
            if rc > 256: rc = rc >> 8		# recover xrdcp return code
	    
	    
    f.close()

    cmd = "eos find -f -x sys.clone=-%s %s > /dev/null" % (cloneId, args[0])
    os.system(cmd)

def do_restore(args):
    #pdb.set_trace()
    global backupDirPrefix
    opts, args = getopt.getopt(args, "B:F:P:")
    trg = args[0] + "/"
    for opt in opts:
        if opt[0] == '-F': catalogFiles = opt[1].split(',')
	elif opt[0] == '-B': backupDirPrefix = opt[1]

    cat = dict()

    backupDirPrefix = '.'.join(catalogFiles[0].split('.')[:-2])
    for fn in catalogFiles:
        lastCatFile = fn == catalogFiles[-1]

        ff = open(fn, "r").readlines()
        (rootPath, ttt) = ff[0].split(' ')	# the rootPath includes the trailing '/'
        cloneInfo = ttt.split(':')
        cloneId = cloneInfo[1]

        for l in ff:
            path, ttt = l.split(' ')
            rpath = path[len(rootPath):]	# skip the "root" part
            stime, clonePath = ttt.split(":")[0:2]

            if rpath in cat:
                if stime < cat[rpath]['stime'] or clonePath.startswith('0'):    # file exists but not part of this backup
                    if lastCatFile: cat[rpath]['keep'] = True
                    continue		# restore latest version
            else: cat[rpath] = dict()
            cat[rpath]['stime'] = stime
            cat[rpath]['cloneId'] = cloneId
            if lastCatFile: cat[rpath]['keep'] = True


    # restore files
    for p in sorted(cat.keys()):	# sorted so that dirs come before their files
	if not 'keep' in cat[p]: continue
	if p.endswith('/') or p == '':
	    os.makedirs(trg + p)
	else:
	    cmd = "cp %s.%s/%s %s/%s" % (backupDirPrefix, cat[p]['cloneId'], p, trg, p)
	    os.system(cmd)

# main
		
try:
  #pdb.set_trace()
  if sys.argv[1] == 'clone':
    do_clone(sys.argv[2:])
  elif sys.argv[1] == 'backup':
    do_backup(sys.argv[2:])
  elif sys.argv[1] == 'restore':
    do_restore(sys.argv[2:])
  else:
    raise NameError
  sys.exit(0)
except (IndexError, NameError) as e:
  print "incorrect argument", "" if type(e) == type(IndexError()) else sys.argv[1]
  sys.exit(1)
